# Clean Architecture Refactoring

**Feature Number**: 001
**Status**: Draft
**Mission**: Software Dev
**Created**: 2025-02-20

---

## Overview

Рефакторинг приложения AI Portal Blog с внедрением слоистой архитектуры для улучшения масштабируемости и удобства поддержки. Проект suffers от взаимосвязанных проблем: сложность компонентов, высокая связность, разрозненная логика интеграции со Strapi, фрагментированный стейт-менеджмент.

**Goal**: Создать устойчивую архитектурную базу для масштабирования с чётким разделением слоёв (UI → Use Cases → Data) без overengineering.

---

## Problem Statement

Текущая архитектура приложения имеет следующие проблемы:

1. **Сложность компонентов**: Много дублирования кода, трудно находить и изменять нужную логику
2. **Высокая связность**: Изменения в одном месте часто ломают другой функционал
3. **Интеграция со Strapi**: Логика запросов и кеширования разбросана по всему коду
4. **Стейт-менеджмент**: Логика состояния распределена фрагментарно по компонентам

Эти проблемы создают технический долг, который будет препятствовать масштабированию проекта и эффективной работе команды.

---

## Proposed Solution

Внедрить слоистую архитектуру с тремя основными слоями:

```
┌─────────────────────────────────────────────────────────┐
│                     Presentation Layer                  │
│  (Components, Pages, Composables — UI logic only)       │
├─────────────────────────────────────────────────────────┤
│                      Application Layer                  │
│  (Use Cases / Services — Business logic, orchestration) │
├─────────────────────────────────────────────────────────┤
│                    Infrastructure Layer                 │
│  (Repositories, API Clients — Data access, external)    │
└─────────────────────────────────────────────────────────┘
```

**Миграция**: Постепенная через создание abstraction layer, затем перенос логики по частям.

---

## Stakeholders

| Role       | Name      | Expectations                                                                 |
|------------|-----------|------------------------------------------------------------------------------|
| Product Owner | — | Функционал остаётся тем же, пользовательский опыт не меняется               |
| Development Team | — | Код становится понятнее, проще находить и изменять логику                    |
| Future Team Members | — | Быстрое онбординг благодаря ясной структуре                                 |

---

## User Scenarios & Testing

### Scenario 1: Разработчик добавляет новую фичу

**Given**: Существующая кодовая база с новой архитектурой
**When** Разработчик создаёт новый use case и подключает его к UI
**Then**:
- Use case создаётся в отдельном файле с чёткой ответственностью
- UI компонент использует use case через composable
- Нет необходимости дублировать логику API запросов или кеширования
- Изменения не затрагивают другие части приложения

### Scenario 2: Изменение API интеграции

**Given**: Архитектура с разделением слоёв
**When** Требуется изменить способ получения данных (например, изменить формат запросов к Strapi)
**Then**:
- Изменения затрагивают только Infrastructure Layer (репозитории)
- Application и Presentation слои остаются неизменными
- Все use cases продолжают работать корректно

### Scenario 3: Добавление нового источника данных

**Given**: Существующая архитектура с use cases
**When** Требуется добавить кеширование в Redis или новый источник данных
**Then**:
- Создаётся новая реализация репозитория
- Use case подключается к новой реализации через интерфейс
- UI слой не требует изменений

### Scenario 4: Рефакторинг компонента

**Given**: Компонент с бизнес-логикой
**When** Разработчик выделяет логику в use case
**Then**:
- Компонент становится проще и отвечает только за отображение
- Логика переносится в тестируемый use case
- Компонент становится переиспользуемым

---

## Functional Requirements

### FREQ-001: Abstraction Layer Creation
Создать базовую структуру слоёв с чёткими границами ответственности:
- Presentation Layer (`/presentation/`) — компоненты, страницы, UI-композаблы
- Application Layer (`/application/`) — use cases, application services
- Infrastructure Layer (`/infrastructure/`) — репозитории, API клиенты
- Domain Layer (`/domain/`) — типы, интерфейсы, business rules

### FREQ-002: Use Cases Pattern
Внедрить паттерн Use Cases для бизнес-операций:
- Каждый use case отвечает за одну бизнес-операцию
- Use cases не зависят от UI фреймворка
- Use cases тестируемы изолированно

### FREQ-003: Repository Pattern
Внедрить паттерн Repository для доступа к данным:
- Репозитории скрывают детали API интеграции
- Каждый репозиторий работает с одной сущностью (Articles, Speckits, Categories)
- Репозитории управляют кешированием

### FREQ-004: Dependency Direction
Обеспечить правильное направление зависимостей:
- Presentation зависит от Application
- Application зависит от Domain и абстракций Infrastructure
- Infrastructure зависит от Domain
- Domain не зависит ни от кого

### FREQ-005: Incremental Migration
Осуществлять постепенную миграцию существующего кода:
- Старый код продолжает работать
- Новые функции используют новую архитектуру
- Существующий код рефакторится по частям

---

## Non-Functional Requirements

### NFR-001: Maintainability
- Новая логика добавляется в предсказуемые места
- Дублирование кода минимизировано
- Связность между модулями снижена

### NFR-002: Testability
- Use cases тестируемы без UI
- Репозитории можно мокать для тестов
- Изоляция слоёв позволяет тестировать каждый отдельно

### NFR-003: Backward Compatibility
- Существующая функциональность не ломается в процессе миграции
- Пользовательский опыт не меняется

### NFR-004: Performance
- Внедрение новых слоёв не ухудшает производительность
- Кеширование сохраняется и улучшается

### NFR-005: Developer Experience
- Структура проекта интуитивно понятна
- Новые разработчики быстро ориентируются в коде

---

## Success Criteria

1. **Структурная организация**: Все новые файлы размещены в соответствии со слоистой архитектурой; существующие файлы мигрированы или находятся в процессе миграции

2. **Снижение дублирования**: Количество дублирующегося кода в компонентах сокращено минимум на 50%

3. **Изоляция слоёв**: Изменения в Infrastructure Layer не требуют изменений в Presentation Layer

4. **Тестируемость**: Минимум 80% бизнес-логики покрыто юнит-тестами

5. **Developer Experience**: Новый разработчик может найти и изменить логику за 15 минут (измеряется через онбординг-задачи)

6. **Zero Regression**: Все существующие функции продолжают работать после миграции каждого модуля

---

## Key Entities

| Entity    | Description                                      |
|-----------|--------------------------------------------------|
| Use Case  | Бизнес-операция (например, "GetSpeckitList")    |
| Repository| Интерфейс доступа к данным (например, "ArticlesRepository") |
| Entity    | Доменная модель (например, "Article", "Speckit") |
| Composable| Presentation layer adapter для use cases         |

---

## Assumptions

1. Команда разработки знакома с TypeScript и Nuxt 3
2. Используемые технологии (Pinia, Strapi) остаются без изменений
3. Рефакторинг выполняется в рамках существующих спринтов
4. Полная миграция займёт несколько итераций
5. Backend API (Strapi) остаётся стабильным

---

## Risks & Mitigations

| Risk                                 | Probability | Impact | Mitigation                                              |
|--------------------------------------|-------------|--------|---------------------------------------------------------|
| Сопротивление команды изменениям    | Medium      | High   | Пошаговая миграция, документация, code review           |
| Проблемы с производительностью      | Low         | Medium | Бенчмарки до/после, оптимизация критических путей      |
| Увеличение времени на разработку    | Medium      | Medium | Начать с новых фич, не блокировать разработку          |
| Ошибки при миграции существующего кода | Medium    | High   | Комплексное тестирование, feature toggles              |

---

## Dependencies

| Dependency           | Type          | Status   |
|----------------------|---------------|----------|
| Существующая кодовая база | Internal | Ready    |
| TypeScript 5.9+      | Technology   | Satisfied|
| Nuxt 3.2+            | Technology   | Satisfied|
| Strapi Backend       | External     | Active   |

---

## Out of Scope

- Изменение UI/UX дизайна
- Смена технологического стека (остаёмся Nuxt 3, Pinia, Strapi)
- Изменение бизнес-логики или функциональности
- Миграция базы данных (остаётся Strapi)
- Деплой и инфраструктура (Docker, hosting)

---

## Open Questions

Отсутствуют. Все ключевые решения определены.

---

## References

- Clean Architecture by Robert C. Martin
- Domain-Driven Design by Eric Evans
- Nuxt 3 Documentation: https://nuxt.com
- Project Repository: `/Users/aleksishmanov/projects/aiportal/aiportal_blog/main`
